#!/usr/bin/env ruby

require 'getoptlong'
require 'pp'

require 'yaml'

require_relative 'classes/dir'

require_relative 'classes/artifacts'
require_relative 'classes/project'
require_relative 'classes/generators'

def showBanner
	unless $noBanner
		puts <<BANNER
   ____   ____   ____   ___________  ____  __ __  ______
  / ___\\_/ __ \\ /    \\_/ __ \\_  __ \\/  _ \\|  |  \\/  ___/
 / /_/  >  ___/|   |  \\  ___/|  | \\(  <_> )  |  /\\___ \\
 \\___  / \\___  >___|  /\\___  >__|   \\____/|____//____  >
\\_____/      \\/     \\/     \\/   project generator    \\/

BANNER
	end
end


# Default options
DEFAULT_CONFIG_FILE = "generous.project"
$noBanner           = false
$configFile         = DEFAULT_CONFIG_FILE

#TODO: HACK... READ PARAMETER...
currentConfig       = 1

# TODO: Migrate from GetoptLong to OptionParser!
opts                = GetoptLong.new(
	['--help', '-h', '-?', GetoptLong::NO_ARGUMENT],
	['--config-file', GetoptLong::REQUIRED_ARGUMENT],
	['--no-banner', GetoptLong::NO_ARGUMENT],
)
opts.quiet          = true

begin
	opts.each do |opt, arg|
		case opt
			when '--no-banner'
				$noBanner = true
			when '--config-file'
				$configFile = arg
			when '--help'
				showBanner
				puts <<-HELP
Usage : #{File.basename $PROGRAM_NAME} [OPTION]...
Generates a project based on the configuration passed.

    --help | -h | -?      Shows this help.
    --config-file <file>  Config file name, default: #{DEFAULT_CONFIG_FILE}

#TODO
    --list-generators     Prints a list of available generators
    --generator <name>    Sets the generator to use

				HELP
				exit
		end
	end
rescue GetoptLong::Error => e
	$stderr.puts e.message
	exit 1
end

# This will show the banner.
showBanner

# TODO: Create a class to handle the configuration (parsing, validating...)
# TODO: Check kwalify http://www.kuwata-lab.com/kwalify/
begin
	projectConfigFile = YAML::load(File.open($configFile))
rescue YAML::SyntaxError => e
	$stderr.puts "Error while analyzing YAML configuration."
	$stderr.puts e.message
	$stderr.puts "In file #{$configFile}"
	exit 1
rescue Errno::ENOENT => e
	# When the file does not exist.
	$stderr.puts e.message
	exit 1
end

project = Project.new projectConfigFile["name"];

# TODO: Clean this up... THIS STINKS AND IS A HACK.
# TODO: Handle multiple levels of includes, aka recursion
# TODO: Handle circular references as errors while recursing.
# This part handles merging configurations together. The current configuration is merged.
if projectConfigFile["configurations"][currentConfig].has_key? "include"

	temp = []

	projectConfigFile["configurations"][currentConfig]["include"].each do |included|
		temp = projectConfigFile["configurations"][currentConfig].merge included do |k, old, new|
			case k
				#When merging, we will always keep the original name.
				when "name"
					old
				when "artifacts"
					old.merge new do |oldkey, oldArtifact, newArtifact|
						oldArtifact.concat new[oldkey]
					end
				else
					$stderr.puts "I don't know how to merge these properties...'"
					$stderr.puts "TODO: Make this a warning and find a middle ground for merging..."
					$stderr.puts
					$stderr.puts "====>" + k
					$stderr.puts "==old"
					$stderr.puts old
					$stderr.puts "==new"
					$stderr.puts new
			end
		end
	end

	temp.delete "include"

	projectConfigFile["configurations"][currentConfig] = temp
end


#TODO: Check other parameters passing in Artifacts... Right now it's a dumb array with [0] being filename, [1] being mask. When not a dumb array (thus, a string) it is converted in that format...
#The first one is technically the default one.
#TODO: Read which configuration to use
#TODO: Configuration names (required?)

#TODO: Artifacts for DEFINES
#TODO: Artifacts for libraries linked
#TODO: Artifacts for include directories

# Here I work out the artifacts.
projectConfigFile["configurations"][currentConfig]["artifacts"].each do |artifactName, artifactValues|
	unless Artifacts.const_defined? artifactName
		raise "Unknown artifact type: #{artifactName}"
	end

	artifactType = Artifacts.const_get artifactName

	artifactValues.each do |artifactValue|
		#TODO: De-hardcode the globbing here... Have some kind of magic for containing the initialization of artifacts through the glob...
		#TODO: Decouple the initialization of an Artifact from the parsing of the config? (Have the glob be applied while parsing the config instead?)
		if artifactType.superclass == Artifacts::FileBasedArtifact
			# When using a simple string, create the right array.
			if artifactValue.is_a? String
				artifactValue = [artifactValue, []]
			end
			Dir.globmask(artifactValue[0], artifactValue[1]).each do |file|
				project.add_artifact artifactType.new(file)
			end
		else
			project.add_artifact artifactType.new(artifactValue)
		end
	end
end


#TODO: Add means to pick a generator

Generators::DumbScript.generate ""

#project.artifacts.each do |art|
#	if art.is_a? Artifacts::FileBasedArtifact
#		puts art.class.name + " : " + art.fileName
#	elsif art.is_a? Artifacts::CompilerConfigurationArtifacts
#		puts art.class.name + " : " + art.value
#	else
#		puts art.class.name + " : UNHANDLED"
#	end
#end


puts "-----"
puts "Done."
puts "-----"